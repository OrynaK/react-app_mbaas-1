"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
var _logger = _interopRequireDefault(require("./logger"));
var GLOBAL_LOGGER_NAME = 'Global logger';
var Logging = /*#__PURE__*/function () {
  function Logging(app) {
    (0, _classCallCheck2["default"])(this, Logging);
    this.app = app;
    this.reset();
    if (app.loggingConfig) {
      this.setConfig(app.loggingConfig);
    }
  }
  (0, _createClass2["default"])(Logging, [{
    key: "setConfig",
    value: function setConfig(config) {
      if (config.levels) {
        this.levels = config.levels;
      }
      if (config.globalLevel) {
        this.globalLevel = config.globalLevel;
      }
      if (config.loadLevels) {
        this.loadLoggingLevels();
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      this.levels = {};
      this.globalLevel = 'all';
      this.loggers = {};
      this.messages = [];
      this.numOfMessages = 10;
      this.timeFrequency = 1;
      this.messagesLimit = 1000;
    }
  }, {
    key: "loadLoggingLevels",
    value: function loadLoggingLevels() {
      var _this = this;
      this.app.request.get({
        url: this.app.urls.loggingLevels()
      }).then(function (loggersList) {
        var loggers = {};
        loggersList.forEach(function (logger) {
          loggers[logger.name] = logger.level;
        });
        var globalLevel = loggers[GLOBAL_LOGGER_NAME];
        _this.setConfig({
          loggers: loggers,
          globalLevel: globalLevel
        });
      })["catch"](function (error) {
        // eslint-disable-next-line no-console
        console.error('Could not load logging levels: ', error);
      });
    }
  }, {
    key: "getLogger",
    value: function getLogger(loggerName) {
      if (!loggerName || typeof loggerName !== 'string') {
        throw new Error('Logger Name must be provided and must be a string.');
      }
      if (!this.loggers[loggerName]) {
        this.loggers[loggerName] = new _logger["default"](loggerName, this);
      }
      return this.loggers[loggerName];
    }
  }, {
    key: "flush",
    value: function () {
      var _flush = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
        var _this2 = this;
        var messages;
        return _regenerator["default"].wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!this.flushRequest && this.messages.length) {
                this.stopFlushInterval();
                messages = (0, _toConsumableArray2["default"])(this.messages);
                this.messages = [];
                this.flushRequest = this.app.request.put({
                  url: this.app.urls.logging(),
                  data: messages
                })["catch"](function (error) {
                  _this2.messages = [].concat((0, _toConsumableArray2["default"])(messages), (0, _toConsumableArray2["default"])(_this2.messages));
                  _this2.checkMessagesLimit();
                  throw error;
                })["finally"](function () {
                  return delete _this2.flushRequest;
                });
              }
              return _context.abrupt("return", this.flushRequest);
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function flush() {
        return _flush.apply(this, arguments);
      }
      return flush;
    }()
  }, {
    key: "push",
    value: function push(logger, logLevel, message, exception) {
      this.messages.push({
        logger: logger,
        message: convertMessageToString(message),
        exception: exception,
        'log-level': logLevel,
        timestamp: Date.now()
      });
      this.checkMessagesLen();
    }
  }, {
    key: "checkMessagesLen",
    value: function checkMessagesLen() {
      var _this3 = this;
      if (this.checkMessagesLenTimer) {
        clearTimeout(this.checkMessagesLenTimer);
      }
      this.checkMessagesLenTimer = setTimeout(function () {
        if (_this3.messages.length >= _this3.numOfMessages) {
          _this3.flush();
        } else {
          _this3.startFlushInterval();
        }
      }, 0);
    }
  }, {
    key: "checkMessagesLimit",
    value: function checkMessagesLimit() {
      if (this.messages.length > this.messagesLimit) {
        this.messages = this.messages.slice(this.messages.length - this.messagesLimit);
      }
    }
  }, {
    key: "startFlushInterval",
    value: function startFlushInterval() {
      var _this4 = this;
      if (!this.flushInterval) {
        this.flushInterval = setTimeout(function () {
          return _this4.flush();
        }, this.timeFrequency * 1000);
      }
    }
  }, {
    key: "stopFlushInterval",
    value: function stopFlushInterval() {
      if (this.flushInterval) {
        clearTimeout(this.flushInterval);
        delete this.flushInterval;
      }
    }
  }, {
    key: "setLogReportingPolicy",
    value: function setLogReportingPolicy(numOfMessages, timeFrequency) {
      if (timeFrequency !== undefined && this.timeFrequency !== timeFrequency) {
        this.stopFlushInterval();
      }
      if (numOfMessages > this.messagesLimit) {
        this.messagesLimit = numOfMessages;
      }
      this.numOfMessages = numOfMessages;
      this.timeFrequency = timeFrequency;
      this.checkMessagesLen();
    }
  }, {
    key: "setMessagesLimit",
    value: function setMessagesLimit(messagesLimit) {
      this.messagesLimit = messagesLimit;
      this.checkMessagesLimit();
    }
  }]);
  return Logging;
}();
exports["default"] = Logging;
function convertMessageToString(message) {
  if (typeof message === 'string') {
    return message;
  }
  if (typeof message === 'undefined') {
    return 'undefined';
  }
  if (typeof message === 'function') {
    return Object.prototype.toString.call(message);
  }
  return JSON.stringify(message);
}