"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sendNodeAPIRequest = sendNodeAPIRequest;
var _utils = require("./utils");
function sendNodeAPIRequest(path, method, headers, body, encoding, timeout) {
  return new Promise(function (resolve, reject) {
    var u = require('url').parse(path);
    var form = (0, _utils.isFormData)(body) && body;
    var https = u.protocol === 'https:';
    var options = {
      host: u.hostname,
      port: u.port || (https ? 443 : 80),
      path: u.pathname + (u.search || ''),
      method: method,
      headers: headers,
      timeout: timeout
    };
    var _send = function _send() {
      var Buffer = require('buffer').Buffer;
      var httpClient = require(https ? 'https' : 'http');
      var req = httpClient.request(options, function (res) {
        var strings = [];
        var buffers = [];
        var bufferLength = 0;
        var body = '';
        var status = res.statusCode,
          statusText = res.statusMessage,
          headers = res.headers;
        res.on('data', function (chunk) {
          if (!Buffer.isBuffer(chunk)) {
            strings.push(chunk);
          } else if (chunk.length) {
            bufferLength += chunk.length;
            buffers.push(chunk);
          }
        });
        res.on('end', function () {
          if (bufferLength) {
            body = Buffer.concat(buffers, bufferLength);
            if (encoding != null) {
              body = body.toString(encoding);
            }
          } else if (strings.length) {
            body = strings.join();
          }
          resolve({
            status: status,
            statusText: statusText,
            headers: headers,
            body: body
          });
        });
        res.on('error', reject);
      });
      req.on('error', reject);
      req.on('timeout', function () {
        req.destroy(new Error('Connection aborted due to timeout'));
      });
      if (body) {
        if ((0, _utils.isStream)(body)) {
          body.pipe(req);
          return;
        }
        req.write(body);
      }
      req.end();
    };
    if (form) {
      Object.assign(options.headers, form.getHeaders());
      form.getLength(function (err, length) {
        if (!err && !isNaN(length)) {
          options.headers['content-length'] = length;
        }
        _send();
      });
    } else {
      if (body && !options.headers['content-length']) {
        var Buffer = require('buffer').Buffer;
        options.headers['content-length'] = Buffer.byteLength(body);
      }
      _send();
    }
  });
}