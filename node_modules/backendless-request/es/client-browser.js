"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sendXmlHttpRequest = sendXmlHttpRequest;
var _request2 = require("./request");
function sendXmlHttpRequest(path, method, headers, body, encoding, timeout, withCredentials) {
  return new Promise(function sendRequest(resolve, reject) {
    var request = new _request2.Request.XMLHttpRequest();
    request.timeout = timeout;
    if (!encoding) {
      request.responseType = 'arraybuffer';
    }
    request.open(method.toUpperCase(), path, true);
    if (typeof withCredentials === 'boolean') {
      request.withCredentials = withCredentials;
    }
    request.onload = function handleLoadEvent() {
      var headers = parseHeaders(request.getAllResponseHeaders());
      var _request = request,
        status = _request.status,
        statusText = _request.statusText;
      var result = {
        status: status,
        statusText: statusText,
        headers: headers
      };
      if (encoding === 'utf8') {
        result.body = request.response || request.responseText;
      } else if (request.response) {
        result.body = new Uint8Array(request.response);
      }
      resolve(result);
      request = null;
    };
    request.onerror = function handleErrorEvent() {
      reject(new Error('Network Error'));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      reject(new Error('Connection aborted due to timeout'));
      request = null;
    };
    Object.keys(headers).forEach(function (key) {
      request.setRequestHeader(key, headers[key]);
    });
    request.send(body);
  });
}
function parseHeaders(headersString) {
  var parsed = {};
  if (!headersString) {
    return parsed;
  }
  headersString.split('\n').forEach(function (line) {
    var i = line.indexOf(':');
    var key = line.substr(0, i).trim();
    var val = line.substr(i + 1).trim();
    if (key) {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });
  return parsed;
}